## RPP Requirements Fulfillment Report

This report details the fulfillment of specified requirements by the RPP (RESTful Provisioning Protocol) architecture document: `draft-kowalik-rpp-architecture-01.clean.txt`.

| Requirement Number | Requirement Text                                                                                                                            | Fulfillment            | Justification                                                                                                                                                                                                                                                                                          | Reference to Section(s) in Architecture Document                                                                 |
| :----------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | :--------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------- |
| **R1.1.** | A well defined architecture MUST be defined for RPP, including a description of the responsibilities of the defined protocol layers.        | Fulfilled              | The document defines a three-layer architecture (HTTP Transport, Data Representation, Resource Definition) in Section 4. Sections 4.2.1, 4.2.2, and 4.2.3 outline the aspects of each layer, and Section 5 (5.1, 5.2, 5.3) provides further details on their responsibilities.                               | 4. "Architectural Overview", 4.2. "Architecture Layers" (specifically 4.2.1, 4.2.2, 4.2.3), 5. "Protocol Details" (specifically 5.1, 5.2, 5.3) |
| **R1.2.** | RPP MUST provide a clear, clean, easy to use and self-explanatory interface that can easily be integrated into existing software systems. | Fulfilled              | Section 1 states RPP aims to be a "modern, standardized, and developer-friendly protocol" leveraging REST and JSON for "ease of integration". The Resource Oriented Architecture (Section 4.1) and use of HTTP further support this goal.                                                               | 1. "Introduction", 4.1. "Resource Oriented Architecture"                                                              |
| **R1.3.** | Wherever applicable RPP SHOULD leverage existing best practices and well adopted standards for building and documenting RESTful APIs. There MUST be a clear justification when deviating from this. | Fulfilled              | Section 4 emphasizes leveraging "existing web standards and principles, particularly HTTP and REST". Section 5.1 states RPP uses best practices from [RFC9205]. OpenAPI is mentioned for documentation (Sections 1, 2, 5.1.9). Adherence to these standards is a core principle.                | 1. "Introduction", 2. "Terminology", 4. "Architectural Overview" (intro), 4.1. "Resource Oriented Architecture", 5.1. "HTTP Transport Layer Details", 5.1.9. "Definition of special resources" |
| **R1.4.** | RPP MUST include support for application level status codes, and MAY reuse the EPP status codes defined in [@!RFC5730].                 | Fulfilled              | Section 5.1.4 details the use of "RPP-specific error codes" alongside HTTP status codes for granular error reporting. While not explicitly stating reuse of EPP codes in 5.1.4, Section 1 mentions "data model compatibility with EPP core objects," suggesting openness to EPP alignment. | 1. "Introduction", 5.1.4. "RPP specific error codes and relation to HTTP error codes"                               |
| **R1.5.** | RPP MAY include support for providing detailed information about application status codes, for example as descibed in [@!RFC7807]        | Fulfilled              | Section 5.1.4 states RPP uses its specific error codes for "detailed error reporting" and to "give granular information about provisioning errors." While RFC7807 is not explicitly named, the architecture supports providing detailed, application-specific error information.             | 5.1.4. "RPP specific error codes and relation to HTTP error codes"                                                              |
| **R1.6** | RPP SHOULD support additional information about a successful operation (information or warning) to convey additional information to the client for example about deprecation or partial success. | Partially Fulfilled    | This version of the draft does not explicitly detail a mechanism for conveying additional information (warnings, deprecation notices) specifically within *successful* responses. Section 5.1.4 mentions "warnings of additional processing information" in the context of error reporting, but not for general success messages. The architecture is flexible, but explicit support for this on success is not detailed. | 5.1.4. (by analogy, for context of "warnings", though primarily for errors) - Explicit support for *success* messages with warnings is not clearly found. |
| **R2.1.** | The Hypertext Transfer Protocol (HTTP) [@!RFC9110] MUST be used as the transport mechanism for RPP.                                       | Fulfilled              | The Abstract describes RPP as an "HTTP based provisioning protocol". Section 4 states "HTTP and RESTful principles are foundational," and Section 4.2.1 specifically defines the "HTTP Transport Layer."                                                                                             | Abstract, 4. "Architectural Overview" (intro), 4.2.1. "HTTP Transport Layer", 5.1. "HTTP Transport Layer Details"     |
| **R2.2.** | RPP SHOULD use the best common practices for designing HTTP based applications, described in [@!BCP56]. There MUST be a clear justification when deviating from this. | Fulfilled              | Section 5.1 explicitly states: "The RPP architecture uses the best practices described in [RFC9205] for the HTTP transport layer." RFC9205 is BCP56.                                                                                                                               | 5.1. "HTTP Transport Layer Details" (intro)                                                                      |
| **R2.3.** | Consistent, predictable and meaningful URL structures MUST be used for for identifying, accessing object resources and enable request routing. | Fulfilled              | Section 4.1 (Resource Oriented Architecture) states "Each resource is uniquely identifiable by a URL." Section 5.1.2 elaborates that "RPP URL structure will be designed to be human-readable, intuitive, and RESTful," and discusses hierarchical structures.                             | 4.1. "Resource Oriented Architecture", 5.1.2. "Resource Addressing"                                                |
| **R2.4.** | RPP MUST use the existing HTTP status codes and MUST define application level status codes and map these to HTTP status codes. RPP MUST NOT redefine existing HTTP status code semantics and when overloading (generic) HTTP status codes with multiple RPP status codes, the provided RPP status code MUST be used by the client to determine the exact nature of the problem. | Fulfilled              | Section 5.1.4 specifies "Use of HTTP status codes to indicate general categories of errors" and "Definition of RPP-specific error codes...provided in the response...to give granular information". This implies HTTP codes retain their semantics, and RPP codes offer specifics.         | 5.1.4. "RPP specific error codes and relation to HTTP error codes"                                                              |
| **R3.1.** | The RPP architecture MUST use the principles of the [@!REST] architectural style. A RPP server MUST conform to at least level 2 of the [@!RICHARDSON] Maturity Model (RMM). | Fulfilled              | The document extensively states its foundation on REST principles (Abstract, Sections 1, 2, 4). Section 4.1 ("Resource Oriented Architecture") and 5.1.3 ("Mapping of basic operations to HTTP uniform interface (verbs)") detail the use of resources and HTTP verbs, aligning with RMM Level 2. | Abstract, 1. "Introduction", 2. "Terminology", 4. "Architectural Overview" (intro), 4.1. "Resource Oriented Architecture", 5.1.3. "Mapping of basic operations to HTTP uniform interface (verbs)" |
| **R3.2** | The RPP architecture MUST follow Resource-Oriented Architecture [@!ROI].                                                                 | Fulfilled              | Section 4.1 is explicitly titled "Resource Oriented Architecture" and states, "RPP adopts a Resource Oriented Architecture (ROA), aligning with RESTful principles."                                                                                                                   | 4.1. "Resource Oriented Architecture"                                                                              |
| **R3.3.** | The RPP specification MUST strive to minimise round trips between client and server. Approaches, where client would need to make multiple requests each time to discover resource URL or server capabilities in order to perform operation SHOULD be used sparingly and be always well justified. | Partially Fulfilled    | The architecture provides mechanisms like service discovery (5.1.10) and response verbosity control via the Prefer header (5.1.7.1) that can help reduce round trips. However, the document does not explicitly mandate the "sparingly and well justified" principle for multi-request operations as a core architectural constraint for all future specifications based on it. | 5.1.7.1. "Prefer Header for Response Verbosity", 5.1.10. "Service discovery mechanisms"                               |
| **R3.4.** | *Merged with R12.1* | N/A                    | This requirement is noted as merged with R12.1, which is not provided for analysis.                                                                                                                                                                                            | N/A                                                                                                              |
| **R3.5.** | RPP specifications SHOULD incorporate a machine-readable and well-established API specification, such as [!@OpenAPI] or [@!RAML]. This will facilitate documentation, testing, code generation, and user-friendly extension descriptions. RPP MUST NOT require what API specification technology is to be used. The RPP core documents and extension documents may also choose different API specification solutions, this choice is left to the document authors. | Fulfilled              | Section 1 mentions OpenAPI for tooling compatibility. Section 2 defines OpenAPI. Section 5.1.9 suggests "Metadata endpoints to provide...OpenAPI definitions". The document does not mandate a specific API specification technology, aligning with the requirement.                | 1. "Introduction", 2. "Terminology", 5.1.9. "Definition of special resources"                                   |
| **R4.1** | The base data model structures MUST be data format agnostic. It MUST be possible to map the base data model to multiple data formats such as JSON, XML or YAML. | Fulfilled              | Section 4.2.3 and 5.3 state the Resource Definition Layer is independent of media type/representation. Section 5.3.2 ("Mapping") details mapping logical data elements to different media types (e.g., JSON, XML).                                                                              | 4.2.3. "Resource Definition Layer", 5.3. "Resource Definition Layer" (intro), 5.3.1. "Data Elements", 5.3.2. "Mapping" |
| **R4.2** | Commonly used EPP extensions SHOULD be added to the RPP core data model. An example of this is the DNSSEC extension.                      | Not Addressed          | The document focuses on core EPP object (domain, host, contact) functional equivalents (Section 1) and general extensibility. It does not specify which, if any, EPP extensions (like DNSSEC) will be part of the RPP core data model itself.                                                | 1. "Introduction"                                                                                                |
| **R4.3** | RPP MUST allow an extension mechanism that allows clients to signal data omission or redaction, indicating data collected but not transmitted to the registry or redacted. (TODO: Issue #34) | Partially Fulfilled    | Section 5.2.2 mentions "JWT-SD: JSON data with Selective Disclosure using JWTs... for minimisation of exposed data." This indicates a potential technology for redaction/omission, but the specific RPP client signaling mechanism is not defined in this architecture draft.          | 5.2.2. "Data format"                                                                                             |
| **R4.4** | RPP MUST have mechanisms to define profiles to indicate: Required parts of the data model, Mapping definition, Functional subsets for compatibility. (TODO: Issue #15) | Not Addressed          | The document contains a "FIXME" in Section 5.3.3 about finding a section for "Compatibility Profiles - to define subsets of RPP for specific use cases or EPP compatibility." This indicates the concept is considered but not yet defined in the architecture.                             | 5.3.3. "Operations" (FIXME note)                                                                                 |
| **R4.5** | The RPP architecture MUST include loose coupling between the server and the client, allowing for non-coordinated introduction of non-breaking version changes on both sides. | Fulfilled              | The layered architecture (4.2), adherence to REST, content negotiation (5.1.7), service discovery (5.1.10), and the general principle of independent evolution promote loose coupling.                                                                                                     | 4.2. "Architecture Layers", 5.1.7. "Content negotiation for media types", 5.1.10. "Service discovery mechanisms"    |
| **R4.6** | A RPP server and client MUST in default ignore unknown properties of representations however there MUST be a mechanism for a client to signal that a strict handling is wished where unknown fields are treated as error. (TODO: Issue #36) | Not Addressed          | The architecture document does not explicitly define a default behavior for handling unknown properties or a client signaling mechanism for strict handling.                                                                                                                      | N/A (Not explicitly addressed in this draft)                                                                     |
| **R5.1** | RPP MUST use JSON as the default data format.                                                                                               | Fulfilled              | The Abstract, Section 1, and Section 5.2.2 ("Data format") explicitly state that JSON is the primary/default data interchange format for RPP.                                                                                                                                    | Abstract, 1. "Introduction", 5.2.2. "Data format"                                                                |
| **R5.2** | It MUST be possible to extended RPP to include support other data formats (e.g. XML, YAML).                                               | Fulfilled              | Section 4.2.2, 5.2.1, and 5.2.2 ("Data format") state RPP should support multiple data structures and can be extended to support other formats like XML, JWT, CBOR.                                                                                                                 | 4.2.2. "Data Representation Layer", 5.2.1. "Data structure", 5.2.2. "Data format"                                  |
| **R5.3** | Validation of request and response message MUST be supported for both clients and the servers, in order to determine if the content is valid and no required attributes are missing. (TODO: Issue #36) | Partially Fulfilled    | The document implies validation through schema definitions (4.2.2, 5.3.1) and the potential use of OpenAPI (R3.5, 5.1.9). However, it doesn't explicitly mandate or detail specific RPP mechanisms for how this validation "MUST be supported" by clients/servers.                 | 4.2.2. "Data structure", 5.1.9. "Definition of special resources", 5.3.1. "Data Elements"                         |
| **R5.4** | RPP MUST define a default media type however the protocol SHALL be extensible to enable support for other media types.                    | Fulfilled              | Section 5.1.7 and 5.2.3 identify 'application/rpp+json' as the primary media type and state potential support for other media types.                                                                                                                                             | 5.1.7. "Content negotiation for media types", 5.2.3. "Media Type definition"                                     |
| **R5.5** | A client MUST be able to signal to the server what media type the server should expect for the request content and to use for the response content. | Fulfilled              | Section 5.1.7 explicitly states RPP supports content negotiation using HTTP 'Accept' and 'Content-Type' headers for this purpose.                                                                                                                                                  | 5.1.7. "Content negotiation for media types"                                                                     |
| **R5.6** | *Removed* | N/A                    | Requirement removed.                                                                                                                                                                                                                                                           | N/A                                                                                                              |
| **R5.7** | RPP SHOULD consider mechanisms for supporting data formats outside of core RPP domain. Especially formats, which lose their properties if transformed, like Verifiable Credentials for contacts which are digitally signed. | Fulfilled              | Sections 5.2.1 and 5.3.2 discuss adapting to Verifiable Credentials (VC) structures and using the mapping layer to support external data formats like VCs as first-class resource types, acknowledging their special properties.                                                  | 5.2.1. "Data structure", 5.3.2. "Mapping"                                                                        |
| **R5.8** | RPP MUST support partial update of data objects.                                                                                            | Fulfilled              | Sections 4.2.1 and 5.1.3 map the PATCH HTTP method to partial updates of resources.                                                                                                                                                                                                  | 4.2.1. "HTTP Transport Layer", 5.1.3. "Mapping of basic operations to HTTP uniform interface (verbs)"            |
| **R5.9** | RPP MUST support full update of data objects.                                                                                               | Fulfilled              | Sections 4.2.1 and 5.1.3 map the PUT HTTP method to updating an existing resource in its entirety.                                                                                                                                                                                   | 4.2.1. "HTTP Transport Layer", 5.1.3. "Mapping of basic operations to HTTP uniform interface (verbs)"            |
| **R5.10** | A generated RPP response representation that includes an object identifier (for example a contact handle) MUST also include a URL reference to the location of the object representation. | Fulfilled              | The adoption of Resource Oriented Architecture (4.1), where resources are identified by URLs, and the use of HTTP verbs to interact with these URLs (5.1.3) inherently supports this. Service discovery (5.1.10) further reinforces the discoverability of resource locations. | 4.1. "Resource Oriented Architecture", 5.1.2. "Resource Addressing", 5.1.3. "Mapping of basic operations to HTTP uniform interface (verbs)", 5.1.10. "Service discovery mechanisms" |
| **R6.1** | RPP MUST include support for a client requesting different depth of data representations, depending on the use case: Minimal representation (ID, or ID+name); Full representation (all data of the object); Full representation + dereferenced referrals (for example domain with contact and host details) | Partially Fulfilled    | Section 5.1.7.1 discusses the `Prefer: return=minimal` header for minimal responses, and the default is a full representation. Support for "full representation + dereferenced referrals" as a standard requestable depth is not explicitly detailed, though the architecture is extensible. | 5.1.7.1. "Prefer Header for Response Verbosity"                                                                  |
| **R6.2** | RPP MAY return different representations of the same object in different contexts: GET request to the resource itself; GET request to get a collection of objects; Responses to PUT/POST/PATCH requests | Fulfilled              | This is a standard RESTful practice. The document's adherence to REST (4.1) and HTTP principles, along with mechanisms like the `Prefer` header (5.1.7.1), allows for varied representations depending on context (e.g., collection vs. individual resource, request type).             | 4.1. "Resource Oriented Architecture", 5.1.7.1. "Prefer Header for Response Verbosity"                             |
| **R6.3** | The data representation in a RPP response MUST only contain data related to the object, transactional information MUST be represented as one or more separate HTTP headers. (TODO: Issue #56) | Fulfilled              | Section 5.1.5 states that transaction tracing and idempotency identifiers "should be defined outside of the Data Representation Layer (e.g. as HTTP Headers)". Section 5.1.4 also suggests RPP-specific error/warning info be in headers.                                           | 5.1.4. "RPP specific error codes and relation to HTTP error codes", 5.1.5. "Transaction tracing and idempotency"   |
| **R7.1** | RPP MAY include a bootstrap mechanism designed to allow clients to locate the network identifier for the RPP service of a registry operator... Solutions may include: IANA bootstrap Service Registry; DNS TXT records | Fulfilled              | Section 5.1.10 explicitly mentions "Potential discovery of RPP server location, like IANA bootstrapppign document or a special DNS TXT RR with location of RPP service for the tld."                                                                                             | 5.1.10. "Service discovery mechanisms"                                                                           |
| **R7.2** | An RPP server MUST publish a service discovery document in the well-known directory, described in [@!RFC5785]. This document contains structured machine readable information... The information may contain, but is not limited to: Available services, Used Extensions, Versions used for services and extensions, Environment name (production, test etc.), Server datetime, Maintenance notices, Supported profiles | Fulfilled              | Section 5.1.10 discusses "Potential use of well-known URIs (e.g., /.well-known/rpp-capabilities)" and lists "Options for advertising supported protocol versions, extensions, available resource types, authentication methods, and supported features." While not an exhaustive match of every listed item (e.g., environment name, server datetime are not explicitly listed for discovery), the mechanism and intent are covered. | 5.1.10. "Service discovery mechanisms"                                                                           |
| **R7.3** | Server provided functionality, such as the set of supported profiles, languages or extensions, MUST discoverable using the discovery document. | Fulfilled              | Section 5.1.10 states service discovery can advertise "supported protocol versions, extensions, available resource types, authentication methods, and supported features." Section 5.1.8 mentions the default language and mechanisms for indicating supported languages will be defined. If profiles are defined (see R4.4 FIXME), they would logically be part of this discoverable information. | 5.1.8. "Language negotiation for textual content", 5.1.10. "Service discovery mechanisms"                       |
| **R7.4** | RPP MUST support versioning of: The protocol itself; Data object types; Representations; Operations; Profiles; Extensions                   | Partially Fulfilled    | Section 5.1.10 mentions advertising "supported protocol versions, extensions." The architecture document itself is versioned. However, explicit mechanisms or requirements for versioning data object types, representations, operations, or profiles are not detailed in this draft. | 5.1.10. "Service discovery mechanisms"                                                                           |
| **R7.5** | Versioning schema MUST carry information about breaking vs. non-breaking changes and allow clients to decide whether it is able to interact with the server. The versioning scheme SHOULD be like the scheme used for HTTP where minor version changes do not break compatibility. | Not Addressed          | While version discoverability is mentioned (R7.4), this draft does not define a specific versioning schema (e.g., SemVer) for RPP components or how breaking vs. non-breaking changes are signaled beyond the general HTTP analogy.                                                 | N/A (Not explicitly addressed in this draft)                                                                     |
| **R7.6** | Notices related to scheduled server maintenance timeslots MAY be included in the discovery document, this could be a human readable, non machine parsable character string. | Not Addressed          | Section 5.1.10, which details service discovery content, does not explicitly mention "maintenance notices." The list of discoverable items is open ("supported features"), so it's not precluded, but not explicitly supported.                                                     | 5.1.10. "Service discovery mechanisms"                                                                           |
| **R7.7** | RPP MAY only support a subset of EPP functionality, the supported functionality MUST be discoverable by the client                        | Fulfilled              | Discoverability of "available resource types... and supported features" (5.1.10) and the planned "Compatibility Profiles" (5.3.3 FIXME) would allow a client to determine the supported EPP functional equivalents.                                                                       | 5.1.10. "Service discovery mechanisms", 5.3.3. "Operations" (FIXME note)                                         |
| **R7.8** | *Removed* | N/A                    | Requirement removed.                                                                                                                                                                                                                                                           | N/A                                                                                                              |
| **R7.9** | An RPP response that includes unique object identifiers, MAY also include URL references for these objects.                                 | Fulfilled              | This is identical to R5.10 and is fulfilled by the Resource Oriented Architecture (4.1), URL-based resource addressing (5.1.2), and use of HTTP verbs (5.1.3).                                                                                                                      | 4.1. "Resource Oriented Architecture", 5.1.2. "Resource Addressing", 5.1.3. "Mapping of basic operations to HTTP uniform interface (verbs)" |
| **R7.10**| Versions used by the RPP protocol and used extensions MUST be discoverable by the client.                                                   | Fulfilled              | Section 5.1.10 explicitly states that service discovery includes "Options for advertising supported protocol versions, extensions..."                                                                                                                                              | 5.1.10. "Service discovery mechanisms"                                                                           |
| **R8.1** | RPP MUST provide functional equivalents for core EPP functionalities related to domain name, host, and contact objects as defined in [@!RFC5731], [@!RFC5732] and [@!RFC5733]. | Fulfilled              | Section 1 states RPP is "initially focusing on functional equivalents of EPP object mappings for domain names [RFC5731], hosts [RFC5732], and contacts [RFC5733]."                                                                                                                | 1. "Introduction"                                                                                                |
| **R8.2** | The automatic or mechanical mapping or conversion between EPP and RPP data model MUST be possible.                                        | Fulfilled              | Section 1 states "RPP aims for data model compatibility with EPP core objects to allow automatic and mechanical mapping and conversion". Section 5.2.1 also mentions adapting EPP XML schemas for data model compatibility.                                                              | 1. "Introduction", 5.2.1. "Data structure"                                                                       |
| **R8.3** | Compatibility definitions for a RPP to EPP mapping MAY be defined in compatibility profiles (see: R4.4). (TODO: Issue #15)                | Not Addressed          | This is linked to R4.4, which has a FIXME note in Section 5.3.3 regarding "Compatibility Profiles." The concept is acknowledged as needed but not yet defined in the architecture.                                                                                               | 5.3.3. "Operations" (FIXME note)                                                                                 |
| **R8.4** | RPP MUST include an extension framework able to define equivalents of most commonly used EPP extensions, which are not a part of core protocol (see: R4.2) | Fulfilled              | The entire architecture is designed for extensibility (Abstract, 4.2.3, 5.3.1, 5.3.3). Section 4.2.3 mentions "Extensibility mechanisms on the resource type level." This framework would be used for defining EPP extension equivalents.                                         | Abstract, 4.2.3. "Resource Definition Layer", 5.3.1. "Data Elements", 5.3.3. "Operations"                         |
| **R8.5** | EPP password based Authorization Information defined in [@!RFC5731] and [@!RFC5733] MUST be supported in RPP.                             | Partially Fulfilled    | Section 5.1.1 states RPP "should also support other authentication schemes defined for HTTP, an example would be HTTP Basic Authentication which might be required for compatibility with existing EPP systems." This implies a path for EPP AuthInfo-like mechanisms, but direct, explicit support for EPP AuthInfo passwords as defined in RFCs is not mandated yet. | 5.1.1. "Authentication and Authorization"                                                                        |
| **R8.6** | RPP SHOULD support client_id/password authentication to match EPP client authentication.                                                  | Partially Fulfilled    | Similar to R8.5, Section 5.1.1 mentions potential support for HTTP Basic Authentication for EPP compatibility. This could serve as a basis for client_id/password, but it's not an explicit "SHOULD support client_id/password" statement.                                            | 5.1.1. "Authentication and Authorization"                                                                        |
| **R9.1** | RPP MUST support state-of-the-art authentication and authorization schemes allowing for easy integration in modern HTTP infrastructure.     | Fulfilled              | Section 5.1.1 states RPP "is aimed to leverage scalable and modern authorization standards, with a focus on OAuth 2.0 [RFC6749] and related frameworks" and "should be able to support future authentication and authorization standards defined for HTTP."                           | 5.1.1. "Authentication and Authorization"                                                                        |
| **R9.2** | RPP MUST support modern authentication and authorization standards (OAuth, OpenId Connect)                                                | Fulfilled              | Section 1 mentions "modern security mechanisms such as OAuth2.0." Section 5.1.1 explicitly focuses on "OAuth 2.0 [RFC6749] and related frameworks." While OpenID Connect isn't explicitly named as mandatory in 5.1.1, OAuth 2.0 is, and OIDC builds on it.                              | 1. "Introduction", 5.1.1. "Authentication and Authorization"                                                       |
| **R9.3** | Support for an simplified and quicker object transfer process MAY be included, where approval from the losing registar is to be obtained interactively by the registrant during the transfer process. | Not Addressed          | The architecture document (specifically 5.1.3 regarding EPP transfer command modeling) describes a way to model transfers but does not detail a "simplified and quicker object transfer process" with interactive registrant approval.                                              | 5.1.3. "Mapping of basic operations to HTTP uniform interface (verbs)"                                           |
| **R9.4** | RPP MUST include an authorisation model/framework that goes beyond the current EPP password based Authorization Information (AuthInfo) used for object transfers. The following use cases MAY be supported: Object transfers without using an EPP password based Authorization Information; Registrants using OpenID Connect can interactively allow DNS operator to update their NS records, directly in the registry database or indirectly using a registar. | Fulfilled              | Section 5.1.1.2 ("Fine-Grained Authorization") states "RPP authorization models may become fine-grained, extending beyond simple auth-code based models used EPP" and mentions OAuth2 RAR [RFC9396]. This directly addresses going beyond EPP AuthInfo. The specific use cases are examples of what such a framework could enable. | 5.1.1.2. "Fine-Grained Authorization"                                                                            |
| **R9.5** | RPP MUST employ strong authentication and utilize encrypted transport (HTTPS) to protect sensitive data.                                  | Fulfilled              | The requirement for HTTP as transport (R2.1, Section 4.2.1) implies HTTPS for secure transport in practice for sensitive data. Section 5.1.1 focuses on "scalable and modern authorization standards." Strong authentication is inherent in these modern standards.                       | 4.2.1. "HTTP Transport Layer", 5.1.1. "Authentication and Authorization"                                           |
| **R9.6** | Security mechanisms SHOULD be flexible to allow operators to choose appropriate methods and support federated authentication scenarios.       | Fulfilled              | Section 5.1.1 states "Implementations will be able to choose authentication and authorization methods appropriate for their security requirements." The focus on OAuth 2.0 also inherently supports federated scenarios.                                                                   | 5.1.1. "Authentication and Authorization"                                                                        |
| **R9.7** | RPP MAY include a mechanism for cryptographic verification of request and response messages as an additional security layer.                | Partially Fulfilled    | Section 5.2.2 mentions "JWT: JSON data encapsulated within a JSON Web Token [RFC7519] for potential use-cases when verifiable data consistency is required." This suggests a mechanism, but it's presented as a data format option rather than a dedicated security layer mechanism for all messages. | 5.2.2. "Data format"                                                                                             |
| **R9.8** | RPP MUST allowing for multiple user accounts linked to a single registrar, registar user management MAY be delegated to an administrator account linked to a registrar, allowing for self service account management by the registar. | Not Addressed          | The current architecture draft (e.g., Section 5.1.1 and its subsections on authorization) focuses on client-server authentication/authorization but does not detail registrar account structures, multiple users per registrar, or delegated administration features.                 | N/A (Not explicitly addressed in this draft)                                                                     |
| **R9.9** | RPP MUST support a granalar authorization matrix, where one or more permissions are coupled to a user account. Allowing for the creation of different types of user accounts, such a readonly users only allowed to fetch data about existing objects, and power users allowed to create and modify objects. | Fulfilled              | Section 5.1.1.1 ("Authorization Scopes") states "RPP specifications will standardize authorization scopes (like rpp:read or rpp:write) to define granular access control". Section 5.1.1.2 ("Fine-Grained Authorization") further elaborates on this.                              | 5.1.1.1. "Authorization Scopes", 5.1.1.2. "Fine-Grained Authorization"                                             |
| **R9.10**| RPP MUST allow users to update their credentials and enforce strong passwords and limited lifetime for passwords and other tokens.          | Not Addressed          | While RPP aims for modern security (R9.1, R9.2), the specifics of user credential management policies (updates, strength, lifetime) are typically part of the identity provider or authentication system RPP integrates with, and are not detailed as RPP-specific architectural mandates in this draft. | N/A (Not explicitly addressed in this draft, likely handled by underlying auth systems like OAuth)                 |
| **R10.1**| The protocol MUST be extensible to accommodate new functionalities, data elements, and operations beyond the initial scope.               | Fulfilled              | The Abstract states "The architecture includes support for extensibility". Section 4.2.3 mentions "Extensibility mechanisms on the resource type level." Section 5.3 also emphasizes that the Resource Definition Layer allows for easy extensibility.                                  | Abstract, 4.2.3. "Resource Definition Layer", 5.3. "Resource Definition Layer" (intro), 5.3.1. "Data Elements", 5.3.3. "Operations" |
| **R10.2**| RPP MUST allow for flexibility in extending the data model e.g. adding new objects or a new attribute to an existing object MUST be possible. | Fulfilled              | Section 4.2.3 ("Resource Definition Layer") details "Extensibility mechanisms on the resource type level" and "Defining the individual data elements...Mechanisms for extensibility, if applicable" (5.3.1). This directly supports adding new attributes or objects.                 | 4.2.3. "Resource Definition Layer", 5.3.1. "Data Elements"                                                         |
| **R10.3**| RPP SHOULD promote standardisation of commonly used extension attributes.                                                                 | Partially Fulfilled    | Section 4.2.3 mentions "IANA registry definitions: Potentially registering resource definitions with IANA for standardized and automated processing." This implies a path to standardization for resource definitions (which include data elements/attributes), but it's not an explicit "SHOULD promote standardization of common extension attributes." | 4.2.3. "Resource Definition Layer", 5.3.1. "Data Elements"                                                         |
| **R10.4**| Extensions for new operations on existing resources MUST be supported. (TODO: Issue #47)                                                  | Fulfilled              | Section 4.2.3 mentions "extending resource types with new... operations." Section 5.1.3 discusses how transform operations beyond basic CRUD can be modeled (e.g., `/_renew`), indicating operational extensibility. Section 5.3.3 states "Each resource type shall define operations possible on this resource type." | 4.2.3. "Resource Definition Layer", 5.1.3. "Mapping of basic operations to HTTP uniform interface (verbs)", 5.3.3. "Operations" |
| **R10.5**| RPP MUST support extensions that define new status codes not already defined in the core RPP RFCs.                                        | Fulfilled              | Section 5.1.4 refers to "Definition of RPP-specific error codes...to give granular information". The architecture is designed for extensibility, and new RPP-specific error codes would be part of an extension defining new functionality or error conditions.                  | 5.1.4. "RPP specific error codes and relation to HTTP error codes"                                               |
| **R10.6**| RPP MUST support extensions adding new HTTP headers.                                                                                      | Fulfilled              | The use of HTTP (R2.1) inherently allows for new HTTP headers. RPP itself defines use of specific headers (e.g., for transaction tracing in 5.1.5, potentially for RPP-specific errors in 5.1.4). Extensions can define their own headers as needed within the HTTP framework.      | Implicit in use of HTTP (4.2.1, 5.1), 5.1.4, 5.1.5                                                               |
| **R10.7**| RPP SHALL have mechanisms to assure conflict avoidance when extending the protocol... There MUST be a mechanism of conflict-free, non-coordinated extending in private/vendor discresion as well as a coordinated process for core, generic or shared elements. (TODO: Issue #10) | Partially Fulfilled    | The document mentions IANA registration for resource definitions (4.2.3) and data elements (5.3.1), implying a coordinated process. However, explicit mechanisms for non-coordinated private/vendor extensions and detailed conflict avoidance strategies are not fully elaborated. | 4.2.3. "Resource Definition Layer", 5.3.1. "Data Elements"                                                         |
| **R10.8**| When a public registry for RPP extensions is required, then IANA MUST be used for this function.                                           | Fulfilled              | The document consistently points to IANA for registration of various protocol elements: resource definitions (4.2.3), data elements (5.3.1), operations (5.3.3), and potentially service discovery (5.1.10). This implies IANA would be the registry for extensions.                   | 4.2.3. "Resource Definition Layer", 5.1.10. "Service discovery mechanisms", 5.3.1. "Data Elements", 5.3.3. "Operations" |
| **R10.9**| RPP extensions MUST include support for versioning, the version of the extention supported by the server MUST be included in the discovery document. (TODO: Issue #11) | Fulfilled              | Section 5.1.10 states that service discovery includes "Options for advertising supported protocol versions, extensions..." This directly covers discoverability of extension versions.                                                                                             | 5.1.10. "Service discovery mechanisms"                                                                           |
| **R10.10**| *Removed* | N/A                    | Requirement removed.                                                                                                                                                                                                                                                           | N/A                                                                                                              |
| **R10.11**| Extension designers or RPP implementers MAY add new status codes, if a newly created status code is generic enough to be useful for the wider RPP community, then the extension designer SHOULD register the new status code in the RPP IANA registry. | Partially Fulfilled    | Section 5.1.4 allows for RPP-specific error codes. The general principle of IANA registration for standardized elements (R10.8) would apply, but the document doesn't explicitly detail the process or "SHOULD register" for generic new status codes defined by extensions.          | 5.1.4. "RPP specific error codes and relation to HTTP error codes" (implies ability to add), R10.8 (implies IANA for registry) |
| **R11.1** | RPP MUST be stateless and MUST NOT maintain application state on the server required for processing future RPP requests. Every client request needs to provide all the information required for the server to be able to successfully process the request. The client MAY maintain application session state, for example by using a JWT token. | Fulfilled | Section 1 mentions "statelessness" as a benefit of REST. Section 4.1 ("Resource Oriented Architecture") lists "Statelessness: Each request to a resource is treated as independent... The server does not maintain client state between requests." | 1. "Introduction", 4.1. "Resource Oriented Architecture" |
| **R11.2** | RPP MUST support cacheability of responses, if applicable to the operation semantics and MUST not include  transaction related identifiers and values. (TODO: Issue #50) | Fulfilled | Section 4.1 ("Resource Oriented Architecture") lists "Cacheability: Responses can be cached to improve performance." Section 5.1.6 ("Caching") states "RPP shall benefit from HTTP standard caching mechanisms...RPP shall define caching policies...including cache-control headers and ETag support." R6.3/5.1.5 ensures transactional info is in headers, separate from cacheable body. | 4.1. "Resource Oriented Architecture", 5.1.5. "Transaction tracing and idempotency", 5.1.6. "Caching" |
| **R11.3** | RPP MUST support load balancing at the level of request messages (URL) and load balancing MUST be possible without processing HTTP body. | Fulfilled | The stateless nature (R11.1/Section 4.1) and use of unique URLs for resources (4.1, 5.1.2) inherently support URL-based load balancing without needing to inspect the body. | 4.1. "Resource Oriented Architecture", 5.1.2. "Resource Addressing" |
| **R11.4** | Every request message MUST at most contain a single object for the server to operate on, with the exception of operations that are explicitely defined as a bulk operation. | Not Addressed | The architecture document does not explicitly state a "single object per request" rule or define how bulk operations would be an exception. REST principles typically focus on single resource operations. | N/A (Not explicitly addressed in this draft) |
| **R11.5** | RPP MUST support asynchronous processing for operations on multiple objects, otherwise resource intensive or involving manual steps. The client request results in a confirmation of receipt and a means for retrieving the final completed processing result at a later time. | Not Addressed | The architecture document, while describing modeling for EPP transfer (5.1.3) which is a process, does not explicitly detail general mechanisms for asynchronous processing for multiple objects, resource-intensive, or manual-step operations with confirmation and later result retrieval. | 5.1.3. "Mapping of basic operations to HTTP uniform interface (verbs)" (for transfer analogy only, not general async) |
| **R12.1** | In order to minimise message sizes and needed processing RPP SHOULD be designed not to include a HTTP message body in the request or response when this is not necessary, for example when the required data can be transmitted using the URL and/or HTTP headers. | Fulfilled | This is a general REST/HTTP best practice. Section 5.1.7.1 (Prefer Header) allows clients to request minimal responses. The use of HTTP HEAD (5.1.3) also avoids response bodies. The design emphasizes leveraging HTTP efficiently. | 5.1.3. "Mapping of basic operations to HTTP uniform interface (verbs)", 5.1.7.1. "Prefer Header for Response Verbosity" |
| **R12.2** | RPP MAY allow for common bulk operations, resource listing, and filtering capabilities. RPP MUST NOT mandate such functionalities where this may impact scalability or performance negatively. | Partially Fulfilled | Section 5.1.2 mentions "URL structure to represent list of related resources," implying listing. Filtering is not explicitly discussed. The document doesn't mandate bulk operations but also doesn't explicitly state they "MUST NOT be mandated if impacting performance negatively." | 5.1.2. "Resource Addressing" |
| **R12.3** | Removed | N/A | Requirement removed. | N/A |
| **R13.1** | RPP MUST support internationalization, for object types and messages defined in the core protocol and extensions | Fulfilled | Section 5.1.2.1 ("Internationalized Domain Names (IDN)") details support for IDNs. Section 5.1.8 ("Language negotiation for textual content") details support for language negotiation using 'Accept-Language' header. | 5.1.2.1. "Internationalized Domain Names (IDN)", 5.1.8. "Language negotiation for textual content" |
| **R13.2** | RPP MUST support human-readable localized response mesages. | Fulfilled | Section 5.1.8 states "Server implementations MAY support multiple languages for textual content in responses to provide human-readable localized responses" and that the application/rpp+json media type may support multi-language representations. | 5.1.8. "Language negotiation for textual content" |
| **R14.1** | RPP MUST support server applications as clients. This will be a primary use-case of registry/registrar integration. | Fulfilled | The entire premise of RPP as an alternative to EPP (Section 1) is for system-to-system (server-to-server) communication, such as between registrars and registries. | 1. "Introduction" (general context) |
| **R14.2** | RPP MUST support interaction from command-line tools or desktop applications capable of sending HTTP requests. Whese can be generic clients such as curl or Postman but also specialized RPP command line tools or scripts. | Fulfilled | As RPP is HTTP-based (R2.1) and adheres to REST principles (R3.1), any standard HTTP client, including curl or Postman, can interact with it. This is an inherent benefit of the chosen architectural style. | Implicit from R2.1 and R3.1 (HTTP/REST based) |
| **R14.3** | RPP SHOULD support web browsers as clients, such as SPA (single page applications) without any proxy backend between webbrowser and the RPP server. | Fulfilled | Section 1 states, "The choice for REST and JSON also facilitates direct browser and mobile application integration including modern security mechanisms such as OAuth2.0." | 1. "Introduction" |
| **R14.4** | RPP SHOULD support mobile applications as clients, also here through direct integration without any proxy backend. | Fulfilled | Section 1 states, "The choice for REST and JSON also facilitates direct browser and mobile application integration including modern security mechanisms such as OAuth2.0." | 1. "Introduction" |
