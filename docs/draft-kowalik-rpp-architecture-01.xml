<?xml version="1.0" encoding="UTF-8"?>
<?rfc notedraftinprogress=""?>
<?rfc rfcedstyle=""?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" docName="draft-kowalik-rpp-architecture-01" category="info" ipr="trust200902" submissionType="IETF" xml:lang="en" version="3" >
  <front>
    <title abbrev="rpp-architecture">RPP Architecture</title>
    <seriesInfo value="draft-kowalik-rpp-architecture-01" status="Informational" stream="IETF" name="Internet-Draft" asciiName="Internet-Draft"></seriesInfo>
    <seriesInfo name="" value="" status="informational"></seriesInfo>
    <author initials="P" surname="Kowalik">
      <organization>DENIC eG</organization>
      <address>
        <postal>
          <street ascii="Theodor-Stern-Kai 1">Theodor-Stern-Kai 1</street>
          <city ascii="Frankfurt am Main">Frankfurt am Main</city>
          <country ascii="DE">DE</country>
        </postal>
        <email>pawel.kowalik@denic.de</email>
        <uri>https://denic.de</uri>
      </address>
    </author>
    <author initials="M" surname="Wullink">
      <organization>SIDN Labs</organization>
      <address>
        <postal>
          <country ascii="NL">NL</country>
        </postal>
        <email>maarten.wullink@sidn.nl</email>
        <uri>https://sidn.nl/</uri>
      </address>
    </author>
    <area>Applications and Real-Time</area>
    <abstract anchor="_ed4e83d1-939d-d957-640b-b5cd34bdbbeb">

<t anchor="_29a5b82f-4eb8-90f9-34b1-3dcdb3b27e58">Advancements in development, integration, deployment environments and operational paradigms have led to a desire for an alternatve for the Extensible Provisioning Protocol (EPP).
This document defines the architecture for the RESTful Provisioning Protocol (RPP) an HTTP based provisioning protocol leveraging the REST architectural style and JSON data-interchange format, aiming to standardize a RESTful protocol for provisioning database objects. The architecture includes support for extensibility, allowing for multiple possible use cases. RPP is intended to co-exist with EPP, offering an alternative protocol including data model compatibility with EPP core objects and the benefits associated with the REST architectural style and widely adopted HTTP-based technologies.</t>


</abstract>
    <note><name>Contributing</name>

<t anchor="_5af36c8b-491f-1b3a-1c7a-7c6648bf4c49">When contributing to this document, please use the following GitHub project: <eref target="https://github.com/pawel-kow/RPP-architecture"></eref>.</t>
</note>
  </front>
  <middle>
    <section anchor="_introduction"><name>Introduction</name>

<t anchor="_93ef62fa-8cbc-6b30-6ff3-84c2849ec8ff">This document outlines the architecture of the RESTful Provisioning Protocol (RPP). RPP aims to provide a modern, standardized, and developer-friendly protocol for provisioning and managing objects in a shared database or registry, initially focusing on functional equivalents of EPP object mappings for domain names <xref target="RFC5731" section="" relative=""></xref>, hosts <xref target="RFC5732" section="" relative=""></xref>, and contacts <xref target="RFC5733" section="" relative=""></xref>. RPP also considers provisioning of other object as a potential use case, aiming for a uniform API layer for various registry operations.</t>

<t anchor="_5281065b-19d8-d76f-f2f2-040d9524676e">RPP is designed to leverage the benefits of REST (REpresentational State Transfer), including statelessness, ease of integration, and compatibility with existing web infrastructure and tooling such as OpenAPI, API gateways, and web application firewalls. By adopting JSON as the data-interchange format, RPP seeks to align with current development practices and the successful deployment patterns observed in protocols such as RDAP <xref target="RFC9082" section="" relative=""></xref>. The choice for REST and JSON also facilitates direct browser and mobile application integration including modern security mechanisms such as OAuth2.0.</t>

<t anchor="_5ab7107c-9b0b-c35a-0257-5facf45bcd47">This architecture document serves as a foundation for a series of specifications that will collectively define RPP. It details the layered approach, core components, and design considerations for building an interoperable and extensible provisioning protocol. RPP is intended to coexist with EPP, offering an alternative for implementers seeking a RESTful approach without aiming to replace EPP or define migration paths from EPP. RPP aims for data model compatibility with EPP core objects to allow automatic and mechanical mapping and conversion, especially for core objects (domain, contact, host).</t>
</section>
    <section anchor="_terminology"><name>Terminology</name>

<t anchor="_85eb04b1-12c5-80eb-8882-5b51a5e95721">This document uses terminology from RFC5730 <xref target="RFC5730" section="" relative=""></xref> and broadly adopts the REST architectural principles as defined in [REST] and related RFCs.</t>

<ul anchor="_85f56869-b7f0-7215-9abd-80e21c2aba26"><li><strong>RPP:</strong> RESTful Provisioning Protocol. The protocol being defined by the RPP working group.</li>
<li><strong>EPP:</strong> Extensible Provisioning Protocol as defined in <xref target="RFC5730" section="" relative=""></xref>.</li>
<li><strong>REST:</strong> REpresentational State Transfer architectural style <xref target="REST" section="" relative=""></xref>.</li>
<li><strong>JSON:</strong> JavaScript Object Notation <xref target="RFC8259" section="" relative=""></xref>.</li>
<li><strong>JWT:</strong> JSON Web Token <xref target="RFC7519" section="" relative=""></xref>.</li>
<li><strong>OpenAPI:</strong> The OpenAPI Specification (OAS) (formerly known as Swagger Specification) is an API description format for REST APIs <xref target="OpenAPI" section="" relative=""></xref>.</li>
</ul>
</section>
    <section anchor="_requirements"><name>Requirements</name>

<t anchor="_5c99410c-d894-3b54-0142-26fa0c9e225e">This document is based on the requirements defined by RPP WG in state from 7.3.2025 <xref target="RPPReq" section="" relative=""></xref>.</t>

<t anchor="_b1c96582-bd82-a25c-560a-7155561e73ed">The actual state of the requirements is present on WG Wiki <eref target="https://wiki.ietf.org/en/group/rpp/requirements"></eref>.</t>
</section>
    <section anchor="_architectural_overview"><name>Architectural Overview</name>

<t anchor="_6d939546-1961-d349-7259-9c4d3e04c283">This chapter provides an overview of the RESTful Provisioning Protocol (RPP) architecture. A key design principle is to leverage existing web standards and principles, particularly HTTP and REST principles. This allows RPP to delegate functionality and features to the well-established infrastructure and semantics of the web, focusing its own definitions on the specific domain of object provisioning. Therefore, we assume:</t>

<ul anchor="_10930888-6351-c2f9-cec0-4079d423c4fb"><li><strong>HTTP and RESTful principles are foundational:</strong> RPP leverages HTTP for transport and adheres to RESTful principles for resource management.</li>
<li><strong>Domain-specific logic resides in data representations:</strong> The specifics of resource provisioning are encoded within the data structures and semantics of the RPP message bodies.</li>
<li><strong>Layered architecture for modularity:</strong> The architecture is layered to promote modularity, separation of concerns, and independent evolution of different aspects of the protocol.</li>
</ul>

<t anchor="_d143895e-c4bf-80a2-73d9-0b839754ceec">The architecture is divided into three main layers: <strong>HTTP Transport</strong>, <strong>Data Representation</strong>, and <strong>Resource Definition</strong>. Each layer defines specific aspects of the protocol. This layered approach allows for clear separation of concerns.</t>

<t anchor="_5e5c29f5-29b5-2301-02ff-e666a3786434"><strong>Data Structure</strong> is a sub-layer of Data Representation and described later in this document. It focuses on the structure of RPP messages.</t>

<t anchor="_faa5d521-943b-4806-ab80-edade0074314">Similarily <strong>Data Elements</strong>, their <strong>Mapping</strong> onto Data Structure and <strong>Operations</strong> are elements of Resource Definition. They focus on the semantic structure of RPP resources and transformation of those resources.</t>

<sourcecode anchor="_08290add-c7d7-73c2-60b0-296316fd689d"><![CDATA[  +---------------------------------------------------------+
  |                      HTTP Transport                     |
  |                                                         |
  | +-----------------------------------------------------+ |
  | |                 Data Representation                 | |
  | |                                                     | |
  | |   +- - - - - - - - - - - - - - - - - - - - - - -+   | |
  | |   |                Data Structure               |<-------+
  | |                                                     | |  |
  | |   | +-----------------------------------------+ |   | |  |
  | |     |           Resource Description          |     | |  |
  | |   | |                                         | |   | |  |
  | |     | +--------------+       +--------------+ |     | |  |
  | |   | | |              |       |              | | |   | |  |
  | |     | |     Data     |       |   Mapping    | |     | |  |
  | |   | | |   Elements   |------>|              |------------+
  | |     | |              |       |              | |     | |
  | |   | | |              |       |              | | |   | |
  | |     | +--------------+       +--------------+ |     | |
  | |   | |     ^                                   | |   | |
  | |     |     |                                   |     | |
  | |   | |     |      +--------------+             | |   | |
  | |     |     |      |              |             |     | |
  | |   | |     |      |  Operations  |             | |   | |
  | |     |     +------|              |             |     | |
  | |   | |            |              |             | |   | |
  | |     |            +--------------+             |     | |
  | |   | |                                         | |   | |
  | |     +-----------------------------------------+ |   | |
  | |   +- - - - - - - - - - - - - - - - - - - - - - -+   | |
  | +-----------------------------------------------------+ |
  +---------------------------------------------------------+]]></sourcecode>


<section anchor="_resource_oriented_architecture"><name>Resource Oriented Architecture</name>

<t anchor="_67f2f11a-00ec-9fb9-2d82-8d8a22589294">RPP adopts a Resource Oriented Architecture (ROA), aligning with RESTful principles. This approach defines all manageable entities as "resources," identified by unique URLs. Operations on these resources are performed through a uniform interface using the standard HTTP methods and their semantics. This contrasts with RPC-style protocols, which often define new and specific operations with custom parameters. ROA promotes a more standardized and interoperable approach, leveraging the existing web infrastructure and its well-defined semantics. Key aspects of ROA within RPP include:</t>

<ul anchor="_37294358-fcb0-aa28-df60-e75fa4195895"><li><strong>Resource Identification:</strong> Each resource is uniquely identifiable by a URL.</li>
<li><strong>Uniform Interface:</strong> HTTP methods (HEAD, GET, POST, PUT, DELETE, PATCH) are used to perform operations on resources in a consistent manner.</li>
<li><strong>Representation:</strong> Resources can be represented in various formats (e.g., JSON, XML) through HTTP standard content negotiation.</li>
<li><strong>Statelessness:</strong> Each request to a resource is treated as independent of previous requests. The server does not maintain client state between requests.</li>
<li><strong>Cacheability:</strong> Responses can be cached to improve performance.</li>
</ul>
</section>

<section anchor="_architecture_layers"><name>Architecture Layers</name>

<section anchor="_http_transport_layer"><name>HTTP Transport Layer</name>

<t anchor="_81b97a29-0b62-39e3-8dfe-e3f597fdff9a">This layer defines the transport mechanism for RPP messages, utilizing HTTP as the underlying protocol.</t>

<t anchor="_8dd025b5-7027-a297-1bc8-706281f49d05">It encompasses aspects such as:</t>

<ul anchor="_a17e9f79-8d87-eb66-63b1-b6b093764395"><li><strong>Authentication and Authorization:</strong> Mechanisms for verifying the identity of clients and controlling access to resources.</li>
<li><strong>Resource Addressing using URLs:</strong> Consistent and meaningful URL structures for identifying, accessing resources and enable request routing.</li>
<li><strong>Mapping of basic operations to HTTP uniform interface (verbs):</strong> Mapping CRUD (Create, Read, Update, Delete) operations to POST, HEAD/GET, PUT/PATCH, and DELETE respectively.</li>
<li><strong>Mapping of operations beyond HTTP uniform interface to URLs and verbs:</strong> Handling more complex operations through appropriate URL structures and HTTP methods.</li>
<li><strong>RPP specific error codes and relation to HTTP error codes:</strong> Defining RPP-specific error codes while relating them to standard HTTP error codes for consistency.</li>
<li><strong>Transaction tracing and idempotency:</strong> Mechanisms for tracking requests and ensuring idempotent operations where appropriate.</li>
<li><strong>Caching:</strong> Leveraging HTTP caching mechanisms to improve performance.</li>
<li><strong>Content negotiation for media types:</strong> Supporting multiple data representation formats and using content negotiation to select the appropriate format.</li>
<li><strong>Language negotiation for textual content:</strong> Supporting multiple languages for textual content and using language negotiation to select the appropriate language.</li>
<li><strong>Definition of special resources:</strong> Defining specific resources for service discovery, metadata retrieval, etc.</li>
<li><strong>Service discovery mechanisms:</strong> Mechanisms for clients to discover available RPP services.</li>
</ul>
</section>

<section anchor="_data_representation_layer"><name>Data Representation Layer</name>

<t anchor="_c2fae37c-1d24-7b8e-5887-54ec40522ad0">This layer focuses on the data representation of RPP messages. It defines the media type used to carry RPP data and supports various data representation formats.</t>

<t anchor="_79e25470-6ecd-43c3-cd9f-5148ca57eff2">It encompasses aspects such as:</t>

<ul anchor="_259a2774-4bfb-f148-17e6-6ea3a102dfc4"><li><strong>Data structure:</strong> Defining the structure and schema of the RPP data, potentially using a specific schema language.</li>
<li><strong>Data format:</strong> Defining the specific format used to represent RPP data within the representation (e.g., JSON, XML or JWT).</li>
<li><strong>Media Type definition:</strong> Defining the specific media type to be used in RPP, including any constraints on the data format and structure</li>
</ul>
</section>

<section anchor="_resource_definition_layer"><name>Resource Definition Layer</name>

<t anchor="_c23fa566-b429-958d-d07a-2dbbaa5ae222">This layer defines the structure and operations for each resource type, independent of media type or representation. It ensures resources are well-defined and allows for easy extensibility and compatibility with different media types.</t>

<t anchor="_b412b923-5166-d82a-d545-3e2a1c1b6137">It encompasses aspects such as:</t>

<ul anchor="_3ab909be-6d1e-48a2-0164-408883ddb6bd"><li><strong>Data elements:</strong> Defining the individual data elements that make up a resource, including their data types, formats, and any constraints.</li>
<li><strong>Resource type definitions:</strong> Defining the structure of specific resource types by combining data elements.</li>
<li><strong>IANA registry definitions:</strong> Potentially registering resource definitions with IANA for standardized and automated processing.</li>
<li><strong>Mapping of data elements to media types:</strong> Defining how the data elements of a resource type are represented in different media types (e.g., JSON, XML).</li>
<li><strong>Extensibility mechanisms on the resource type level:</strong> Providing mechanisms for extending resource types with new data elements or operations.</li>
</ul>
</section>
</section>
</section>
    <section anchor="_protocol_details"><name>Protocol Details</name>

<t anchor="_49ce51bb-646a-7c24-4885-afdd28ba177b">This section provides further details on each layer of the RPP architecture.</t>

<section anchor="_http_transport_layer_details"><name>HTTP Transport Layer Details</name>

<t anchor="_5a15c9db-ce4e-82f7-89c2-8034a2286542">The RPP architecture uses the best practices described in <xref target="RFC9205" section="" relative=""></xref> for the HTTP transport layer.</t>

<section anchor="authentication-authorization"><name>Authentication and Authorization</name>

<t anchor="_fa5640c4-bc17-ed50-54a3-54316b000b50">RPP is aimed to leverage scalable and modern authorization standards, with a focus on OAuth 2.0 <xref target="RFC6749" section="" relative=""></xref> and related frameworks, however it should also support other authentication schemes defined for HTTP, an example would be HTTP Basic Authentication which might be required for compatibility with existing EPP systems. RPP should be able to support future authentication and authorization standards defined for HTTP.</t>

<t anchor="_c010fa10-ef15-9f84-7caa-57c59380f117">Specifications will define profiles for:
*  HTTP Authentication schemes (e.g., HTTP Basic Authentication, Bearer Token <xref target="RFC6750" section="" relative=""></xref> etc.)
*  Authorization frameworks (e.g., OAuth 2.0 <xref target="RFC6749" section="" relative=""></xref>)</t>

<t anchor="_49764d22-2911-7bbe-83a0-6fefc2274565">Implementations will be able to choose authentication and authorization methods appropriate for their security requirements.</t>

<section anchor="_authorization_scopes"><name>Authorization Scopes</name>

<t anchor="_caf77f4d-2263-cf9f-012f-f8c932a77c25">RPP specifications will standardize authorization scopes (like rpp:read or rpp:write) to define granular access control for different usage scenarios. These scopes will be defined for various operations and resource types, ensuring that clients can be granted only the necessary permissions.</t>
</section>

<section anchor="_fine_grained_authorization"><name>Fine-Grained Authorization</name>

<t anchor="_8c4e6992-c7ae-b1f7-c09a-aff596f5a177">RPP authorization models may become fine-grained, extending beyond simple auth-code based models used EPP. Authorization decisions will be able to consider the specific operation being performed (e.g., update vs. read), the resource being accessed (e.g., a specific domain name), and potentially even attributes within the resource.</t>

<t anchor="_f54c6cb0-d859-1ebd-d778-9706cf28124f">Here solutions like OAuth2 RAR <xref target="RFC9396" section="" relative=""></xref> could be considered to provide fine-grained access control.</t>
</section>
</section>

<section anchor="_resource_addressing"><name>Resource Addressing</name>

<t anchor="_120f6c06-7695-d222-2610-301621a78294">RPP resources are addressed using URLs. Considerations include:</t>

<ul anchor="_376f3f94-d04d-9063-0562-04a2b9905be7"><li>Hierarchical URL structure to represent resources of different type (e.g., <tt>/domains/{domain-name}</tt>, <tt>/contacts/{contact-id}</tt>).</li>
<li>URL structure to represent list of related resources (e.g., <tt>/domains/{domain-name}/contacts/</tt>)</li>
</ul>

<t anchor="_30e662cf-16a7-887c-f31e-9c7db05e0630">RPP URL structure will be designed to be human-readable, intuitive, and RESTful, allowing clients to easily navigate and interact with resources.</t>

<t anchor="_4c124870-2cc5-e5ac-0de9-ee4f273e070c">RPP would not require all URLs to be hard wired to server's RPP root URL. Instead, it would allow for relative URLs to be defined and discovered by the client. This would allow servers to distibute resources across multiple servers and URLs and allow for easier scaling as described in <xref target="RFC9205" section="" relative=""></xref>.</t>

<t anchor="_2cdcb6f0-0271-0041-5448-54a29b3215c8">As a matter of extensibility consideration RPP should allow for additional path segments to be added to the URLs and be discoverable by clients.</t>

<section anchor="_internationalized_domain_names_idn"><name>Internationalized Domain Names (IDN)</name>

<t anchor="_42645e3a-03dd-1f0f-1a5e-898de9b94ebe">RPP will address the handling of Internationalized Domain Names (IDNs) in resource addressing. Specifications will define whether to use IDN or UTF-8 encoding directly in URLs and whether to employ redirects to canonical URLs or "see-also" linking for alternative representations. For example,  a "see-also" link could point from a UTF-8 encoded URL to an IDN URL and vice versa, allowing clients to use either URL. Another way would be to always redirect to the canonical URL, which would be the IDN URL.</t>
</section>
</section>

<section anchor="_mapping_of_basic_operations_to_http_uniform_interface_verbs"><name>Mapping of basic operations to HTTP uniform interface (verbs)</name>

<t anchor="_00acacd2-fcd0-837d-361c-fecc3edd08a2">RPP operations are mapped to standard HTTP methods to leverage the
uniform interface and RESTful principles:</t>

<ul anchor="_fca79b72-e2c9-1312-6d82-164b269d3b1a"><li><t anchor="_be57097b-8ece-385d-11a4-92864ad194c3"><strong>HEAD:</strong>  Retrieve resource state (e.g., retrieving domain existence information). This may be a candidate for equivalence of EPP check command, however it may come with few caveats to consider:</t>
<ul anchor="_994e2762-cbec-601f-b27d-4d80b48dfdd6"><li>EPP check is intended to check whether domain registration is possible. This is not semantically the same as resource state. Overloading HEAD with EPP semantics may lead to confusion, especially that some frameworks implicitely implement HEAD out or GET handling.</li>
<li>a better equivalence of EPP check would be a POST with Expect header</li>
</ul>
</li>
<li><strong>GET:</strong>  Retrieve resource state (e.g., retrieving domain or contact information) - EPP info command</li>
<li><strong>POST:</strong> Create a new resource (e.g., registering a domain or create contact object) - EPP create command</li>
<li><strong>PUT:</strong>  Update an existing resource in its entirety (e.g., updating domain registration details) - not 100% equivalent of EPP update command</li>
<li><strong>DELETE:</strong> Delete a resource (e.g., deleting a domain registration) - EPP delete command</li>
<li><strong>PATCH:</strong>  Partially modify a resource (e.g., updating specific attributes of a domain or contact) - EPP update command</li>
</ul>

<t anchor="_fee604f6-8ddd-de50-1315-4bc2887618a7">EPP transfer commands (query and transform), being in fact a representation of a running process, may be modelled by a subresource <tt>/transfer</tt> of the resource being transferred, with a PUT operation to initiate the transfer, GET operation to query the transfer status and POST operation to approve or reject the transfer. The same approach may apply when adding any other process to the resource, like domain restore.</t>

<t anchor="_ab45b50d-de28-24cf-6ada-39f842628e4c">EPP check command may be modelled either as a GET operation with a dedicated media type, a POST operation with Expect header or a HEAD verb - depending on the specific requirements of the check operation.</t>

<t anchor="_90f58059-e856-c769-59ce-7ef5bba68d9b">Other transform operations like renew, or restore which are not addressable resources in terms of REST may be either also modelled as POST requests with a dedicated media type, or be a convention of URLs with processing resources with only POST interface starting with underscore, e.g. <tt>/domains/{domain-name}/_renew</tt>.</t>

<t anchor="_2e3935ac-8469-3cfd-fc77-1ea07675c6ff">This basic set of rules and guidelines will be further refined in the RPP specifications and give an universal toolset for extending RPP with new resources and commands.</t>
</section>

<section anchor="_rpp_specific_error_codes_and_relation_to_http_error_codes"><name>RPP specific error codes and relation to HTTP error codes</name>

<t anchor="_669c6d0d-4e1b-5297-c159-38bc87d54f9a">RPP utilizes both HTTP status codes and RPP-specific error codes within RPP-specific HTTP Headers and the response body for detailed error reporting and allowing the client or an intermediate to determine what action to take based on status code and header details only.</t>

<ul anchor="_57bd988c-f8c3-6fe6-21db-ca6180930de0"><li>Use of HTTP status codes to indicate general categories of errors (e.g., 2xx success responses, 4xx for client errors, 5xx for server errors) <xref target="RFC7231" section="" relative=""></xref>.</li>
<li>Use of additional signalling already standardised for HTTP, for example for rate limiting</li>
<li>Definition of RPP-specific error codes, warnings of additional processing information, provided in the response, preferably outside of resource representation (e.g. in HTTP Headers) to give granular information about provisioning errors.</li>
<li>Categorization of RPP error codes as temporary or permanent to guide client retry behavior.</li>
</ul>
</section>

<section anchor="_transaction_tracing_and_idempotency"><name>Transaction tracing and idempotency</name>

<t anchor="_85ae51f0-838f-e0c4-50d4-ab565aa69389">RPP shall support identification of requests and reponses on both client side and server side with use of client provided identifiers  and server provided identifiers. This will allow for tracking of requests and responses in case of errors, and for idempotency of requests. This should be defined outside of the Data Representation Layer (e.g. as HTTP Headers), to assure clear separation of resourse representation from performed actions. If possible existing mechanisms of HTTP shall be employed.</t>
</section>

<section anchor="_caching"><name>Caching</name>

<t anchor="_063f076e-3c15-bba4-90d2-76f8d36f5e42">RPP shall benefit from HTTP standard caching mechanisms to enable standard components like proxies and caches to improve performance and reduce load on servers. RPP shall define caching policies for different resources and operations, including cache-control headers and ETag support.</t>
</section>

<section anchor="_content_negotiation_for_media_types"><name>Content negotiation for media types</name>

<t anchor="_815590c1-dec0-cf40-fd2c-08217da08e3a">RPP supports content negotiation to allow clients to specify preferred media types for request and response payloads using the HTTP 'Accept' and 'Content-Type' headers <xref target="RFC7231" section="" relative=""></xref>.</t>

<ul anchor="_10f7bc60-57b2-68ad-7c82-f401ddc2903c"><li>Support for 'application/rpp+json' as the primary media type.</li>
<li>Potential support for other media types defined in the Data Representation Layer</li>
</ul>

<section anchor="_prefer_header_for_response_verbosity"><name>Prefer Header for Response Verbosity</name>

<t anchor="_762fdbb9-313e-fbf2-f47c-77a2d1b007d4">RPP may utilize the HTTP <tt>Prefer</tt> header <xref target="RFC7240" section="" relative=""></xref> with the "return" preference to allow clients to control the verbosity of responses. For example, clients not interested in full resource representations could use <tt>Prefer: return=minimal</tt> to request minimal responses, reducing payload sizes and improving efficiency. The default behavior, without the <tt>Prefer</tt> header, would be to return a full resource representation, similar to object info responses in EPP, especially after compound requests are completed.</t>
</section>
</section>

<section anchor="_language_negotiation_for_textual_content"><name>Language negotiation for textual content</name>

<t anchor="_a26b6e17-0348-fc19-5b4c-084ffca48079">RPP shall support language negotiation to enable clients to request
responses in a preferred language using the HTTP 'Accept-Language'
header <xref target="RFC7231" section="" relative=""></xref>.</t>

<ul anchor="_abaaf0a7-d181-47c8-acba-b82efd37ce7e"><li>Server implementations MAY support multiple languages for
textual content in responses to provide human-readable localized responses.</li>
<li>The default language and mechanisms for indicating supported
languages will be defined, preferably using HTTP methods, like OPTIONS or HEAD requests.</li>
<li>application/rpp+json media type may support multi-language representations, especially for witing operations involving user provided content. Other media types may have different mechanisms for language representation.</li>
</ul>
</section>

<section anchor="_definition_of_special_resources"><name>Definition of special resources</name>

<t anchor="_a16b1f15-e1de-6c86-43b6-85a62e6060e5">RPP may define special resources for specific purposes:</t>

<ul anchor="_c0af9fd2-2582-20e2-48ed-75131c2bb670"><li>Service Discovery endpoints to advertise protocol capabilities
and supported features (see <xref target="service-discovery"></xref>).</li>
<li>Metadata endpoints to provide schema information or other
protocol-level metadata, potentially including OpenAPI definitions for documentation and code generation.</li>
</ul>
</section>

<section anchor="service-discovery"><name>Service discovery mechanisms</name>

<t anchor="_450bcef2-f12a-22ea-ec1f-dc5aa6f2d6b7">RPP will define mechanisms for service discovery, allowing clients
to dynamically discover RPP service endpoints and capabilities, reducing coupling between clients and servers.</t>

<ul anchor="_beec2a36-2e04-b0e1-4d2d-d37883e9d8f9"><li>Potential discovery of RPP server location, like  IANA bootstrapppign document or a special DNS TXT RR with location of RPP service for the tld.</li>
<li>Potential use of well-known URIs (e.g., <tt>/.well-known/rpp-capabilities</tt>) for service discovery.</li>
<li>Options for advertising supported protocol versions,
extensions, available resource types, authentication methods, and supported features.</li>
<li>It may be considered for RPP to distribute service discovery for each resource type separately for better scalability and management. For example instead of having a single service discovery endpoint for the whole registry on <tt>/.well-known/rpp-capabilities</tt> there might be a separate discovery placed under <tt>/{resource-type}/.well-known/rpp-capabilities</tt> e.g. <tt>/domains/.well-known/rpp-capabilities</tt>.</li>
<li>Service discovery shall utilize standardised methods, like URI templates <xref target="RFC6570" section="" relative=""></xref> to allow easy navigation of resources and avoid hard-coding of URLs.</li>
</ul>
</section>
</section>

<section anchor="_data_representation_layer_2"><name>Data Representation Layer</name>

<t anchor="_cab59309-6516-7664-b50d-5861629369f0">This layer focuses on the data representation of RPP messages. It defines the media type used to carry RPP data and supports various data representation formats.</t>

<section anchor="_data_structure"><name>Data structure</name>

<t anchor="_300f43c3-e817-33f6-03d4-d970a483e95b">RPP will define the overall structure of the message payload carried
by the chosen media type. By default one data structure will be defined, however RPP should be able to support multiple data structures, especially for compatibility with EPP and other standards.</t>

<ul anchor="_0b081cd4-a307-ff61-d080-aa315a7e5142"><li><strong>'RPP' Structure:</strong>  Defining a new, dedicated data structure
specifically for RPP messages. This would be the default in core specifications.</li>
</ul>

<t anchor="_f1939749-50b8-b2ec-2e59-b693229cff3c">Other future possibilities:</t>

<ul anchor="_d7484cd9-f226-7d6c-21cf-a7cf9edc825e"><li><strong>'EPP' Structure Adaptation:</strong>  Reusing or adapting to the existing EPP XML schemas, to maintain data model compatibility with EPP core objects and simplify mapping from EPP.</li>
<li><strong>'JSContact' Structure Adaptation:</strong>  Adapting to the existing JSON representation for Contact Information <xref target="RFC9553" section="" relative=""></xref>, to maintain alignment with RDAP.</li>
<li><strong>'VC' Structure Adaptation:</strong>  Adapting to existing Verifiable Credentials (<xref target="W3C-VC" section="" relative=""></xref>, <xref target="I-D.draft-ietf-oauth-sd-jwt-vc" section="" relative=""></xref>) data structures, especially for representing identity or authorization information, allowing for integration with external identity systems.</li>
</ul>
</section>

<section anchor="_data_format"><name>Data format</name>

<t anchor="_0bb7b854-4698-a5a0-161b-11d754b0a3f3">The primary format for RPP data represetations shall be JSON, however RPP should be able to be extended to support other formats like XML, JWT, JWT-SD or CBOR.</t>

<ul anchor="_2d047984-3db6-3e1e-6b74-f3d947980ad1"><li><strong>JSON:</strong> Standard JSON format <xref target="RFC8259" section="" relative=""></xref>.</li>
<li><strong>XML:</strong> eXtensible Markup Language <xref target="XML" section="" relative=""></xref> (considered for potential compatibility with EPP).</li>
<li><strong>JWT:</strong> JSON data encapsulated within a JSON Web Token <xref target="RFC7519" section="" relative=""></xref> for potential use-cases when verifiable data consistency is required</li>
<li><strong>JWT-SD:</strong> JSON data with Selective Disclosure using JWTs <xref target="I-D.draft-ietf-oauth-selective-disclosure-jwt" section="" relative=""></xref> for minimisation of exposed data.</li>
<li><strong>CBOR:</strong> Concise Binary Object Representation for specific use cases requiring compact binary encoding <xref target="RFC8949" section="" relative=""></xref>.</li>
</ul>

<t anchor="_e0b16fe5-774d-9d89-3e9c-4695616e2025">Some data formats can be optionally represented in other encapsulations, for example JSON data can be represented also in JWT or CBOR. Change of encapsulation shall not affect the data structure. This might be beneficial if RPP is to be extended to support different data formats in the future that only require additional properties provided by encapsulation, like signing, encryption or binary representation.</t>
</section>

<section anchor="_media_type_definition"><name>Media Type definition</name>

<t anchor="_a20920e8-0d0b-4cf1-a4b9-6121ba356b76">Together data structure and data format would define the whole media type. So application/rpp+json would be the primary media type with "rpp" payloads in plain json format. application/epp+xml would be epp payload as per <xref target="RFC5730" section="" relative=""></xref>.</t>
</section>
</section>

<section anchor="_resource_definition_layer_2"><name>Resource Definition Layer</name>

<t anchor="_bdcf77e8-669c-1412-4b1c-56f61c5c426c">Each resource type, no matter if on a top level, being an independent provisioning object, or a subresource, being a part of another resource, shall be well defined including data elements and possible operations. A respource definition shall on the first level of abstraction be composable out of data elements, without any reference to the media type or representation. This will allow for easy extensibility and compatibility with different media types.</t>

<t anchor="_4d2f5cf2-4741-0bcd-2e2d-34db056734e8">All resource types shall be defined in IANA registry in a way that allows fully automated processing of the resource definition, including data elements, operations and media type representation.</t>

<section anchor="_data_elements"><name>Data Elements</name>

<t anchor="_7705ccb4-da5a-6b8d-50d0-1c38b18b103f">This part defines logical data elements for each resource type, which can also be re-used across resource types. It is abstracted from the actual transport and media type, focusing on the structure and constraints of data elements. Data element definition includes:</t>

<ul anchor="_69d88361-1b21-f800-ef99-05b52c9682fb"><li>Identification of logical data units (e.g. a stable identifier of a data element, which is independent of the representation)</li>
<li>Definition of logical data units (e.g., domain name, contact details)</li>
<li>Format and schema for primitive data elements or reference to other resource type definitions</li>
<li>Constraints on data elements (e.g., data type, length, allowed values)</li>
<li>Mechanisms for extensibility, if applicable</li>
</ul>

<t anchor="_89a8dbf8-e131-aed0-a83b-799db5ca790a">Data elements shall be defined in IANA registry in a way that allows for automated processing of the data element definition, including constraints and references to other data elements.</t>
</section>

<section anchor="_mapping"><name>Mapping</name>

<t anchor="_072d220d-29a5-4071-ebea-39569c6e9b6c">This layer defines the mapping of Data Elements onto the Data Representation Layer. For example in case of application/rpp+json media type, the mapping layer would define how the logical data units are represented in JSON format.</t>

<t anchor="_35d82a08-c171-6f4b-cdcf-f5eb7db99aac">This additional level of indirection would allow usage of data formats defined outside of rpp specifications - for example usage of Verifiable Credentials or Verifiable Presentations as first class resource types for contacts in RPP, and mapping appropriate data elements.</t>

<t anchor="_63cf264a-d873-ee0f-2068-293a6c3872ef">The mapping layer shall be defined in IANA registry in a way that allows for automated processing of the mapping definition, including reading and writing operations. Mechanisms, such as defined for JavaScript Object Notation (JSON) Patch <xref target="RFC6902" section="" relative=""></xref>, may be used to define the mapping.</t>
</section>

<section anchor="_operations"><name>Operations</name>

<t anchor="_b4b9101d-611e-1dfc-7284-ebf6a4a5d6bf">Each resource type shall define operations possible on this resource type. This may encompass any of the mechanism defined on the HTTP transport layer and be constrained by those extensibility rules.</t>

<t anchor="_003bc0cf-5af2-8308-4c0b-8877e188992c">Operations shall be defined in IANA registry in a way that allows for automated processing of the operation definition, including constraints and references to other resource types.</t>

<t anchor="_a3ce1d78-9e95-9d5a-b876-1759afb0408d">FIXME: find an appropriate section for this
*  Compatibility Profiles - to define subsets of RPP for specific use cases or EPP compatibility.</t>
</section>
</section>
</section>
    <section anchor="_change_history"><name>Change History</name>

<section anchor="_00_to_01"><name>-00 to -01</name>

<ul anchor="_61618e31-a9bf-c31d-6b28-ad7334978512"><li>Removed requirements and replaced with a reference to RPP WG</li>
<li>Encapsulation removed as a primary extension point and part of architecture</li>
<li>Added reference to JSContact as a possible contact representation</li>
<li>Added HEAD verb to basic operations</li>
</ul>
</section>
</section>
  </middle>
  <back>
    <references anchor="_references">
      <name>References</name>
      <references anchor="_informational_references">
        <name>Informational References</name>
        <reference target="https://www.rfc-editor.org/info/rfc5730" anchor="RFC5730"><stream>IETF</stream> <front> <title>Extensible Provisioning Protocol (EPP)</title> <author fullname="S. Hollenbeck" asciiFullname="S. Hollenbeck"></author> <date month="August" year="2009"></date> <keyword>shared framework mapping</keyword> <abstract>  <t anchor="_ec6563c8-fa2a-357d-e833-1b952ed1826f">This document describes an application-layer client-server protocol for the provisioning and management of objects stored in a shared central repository. Specified in XML, the protocol defines generic object management operations and an extensible framework that maps protocol operations to objects. This document includes a protocol specification, an object mapping template, and an XML media type registration. This document obsoletes RFC 4930. [STANDARDS-TRACK]</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc5730" type="src"></format> <seriesInfo name="STD" value="69"></seriesInfo> <seriesInfo value=" 10.17487/RFC5730" name="DOI"></seriesInfo> <seriesInfo value="69" name="BCP"></seriesInfo> <seriesInfo value="5730" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc5731" anchor="RFC5731"><stream>IETF</stream> <front> <title>Extensible Provisioning Protocol (EPP) Domain Name Mapping</title> <author fullname="S. Hollenbeck" asciiFullname="S. Hollenbeck"></author> <date month="August" year="2009"></date> <keyword>EPP</keyword><keyword>Extensible Provisioning Protocol</keyword><keyword>XML</keyword><keyword>domain</keyword><keyword>domain name</keyword> <abstract>  <t anchor="_4b69770f-fe61-11c1-2ba8-d5ec2214d9c1">This document describes an Extensible Provisioning Protocol (EPP) mapping for the provisioning and management of Internet domain names stored in a shared central repository. Specified in XML, the mapping defines EPP command syntax and semantics as applied to domain names. This document obsoletes RFC 4931. [STANDARDS-TRACK]</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc5731" type="src"></format> <seriesInfo name="STD" value="69"></seriesInfo> <seriesInfo value=" 10.17487/RFC5731" name="DOI"></seriesInfo> <seriesInfo value="69" name="BCP"></seriesInfo> <seriesInfo value="5731" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc5732" anchor="RFC5732"><stream>IETF</stream> <front> <title>Extensible Provisioning Protocol (EPP) Host Mapping</title> <author fullname="S. Hollenbeck" asciiFullname="S. Hollenbeck"></author> <date month="August" year="2009"></date> <keyword>EPP</keyword><keyword>Extensible Provisioning Protocol</keyword><keyword>XML</keyword><keyword>host</keyword> <abstract>  <t anchor="_78290f07-714c-efd8-4fb6-f0d48119f6de">This document describes an Extensible Provisioning Protocol (EPP) mapping for the provisioning and management of Internet host names stored in a shared central repository. Specified in XML, the mapping defines EPP command syntax and semantics as applied to host names. This document obsoletes RFC 4932. [STANDARDS-TRACK]</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc5732" type="src"></format> <seriesInfo name="STD" value="69"></seriesInfo> <seriesInfo value=" 10.17487/RFC5732" name="DOI"></seriesInfo> <seriesInfo value="69" name="BCP"></seriesInfo> <seriesInfo value="5732" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc5733" anchor="RFC5733"><stream>IETF</stream> <front> <title>Extensible Provisioning Protocol (EPP) Contact Mapping</title> <author fullname="S. Hollenbeck" asciiFullname="S. Hollenbeck"></author> <date month="August" year="2009"></date> <keyword>EPP</keyword><keyword>Extensible Provisioning Protocol</keyword><keyword>XML</keyword><keyword>contact</keyword><keyword>registrant</keyword> <abstract>  <t anchor="_2d11c153-9237-8c70-1e11-73779e984683">This document describes an Extensible Provisioning Protocol (EPP) mapping for the provisioning and management of individual or organizational social information identifiers (known as "contacts") stored in a shared central repository. Specified in Extensible Markup Language (XML), the mapping defines EPP command syntax and semantics as applied to contacts. This document obsoletes RFC 4933. [STANDARDS-TRACK]</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc5733" type="src"></format> <seriesInfo name="STD" value="69"></seriesInfo> <seriesInfo value=" 10.17487/RFC5733" name="DOI"></seriesInfo> <seriesInfo value="69" name="BCP"></seriesInfo> <seriesInfo value="5733" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc7231" anchor="RFC7231"><stream>IETF</stream> <front> <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title> <author fullname="R. Fielding" asciiFullname="R. Fielding"></author> <author fullname="J. Reschke" asciiFullname="J. Reschke"></author> <date month="June" year="2014"></date> <keyword>Hypertext Transfer Protocol</keyword><keyword>HTTP</keyword><keyword>HTTP semantics</keyword><keyword>HTTP payload</keyword><keyword>HTTP content</keyword><keyword>HTTP method</keyword><keyword>HTTP status code</keyword> <abstract>  <t anchor="_f6c4e8b6-4042-9173-296e-1ebe87409193">The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems. This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc7231" type="src"></format> <seriesInfo value=" 10.17487/RFC7231" name="DOI"></seriesInfo> <seriesInfo value="7231" name="RFC"></seriesInfo></reference>
        <reference anchor="REST">
          <front>
            <title>Fielding, R., "Architectural Styles and the Design of Network-based Software Architectures", Doctoral Dissertation, University of California, Irvine, September 2000, &#x3e;.</title><author surname="Unknown"></author>
          </front>
        </reference>
        <reference target="https://www.rfc-editor.org/info/rfc7240" anchor="RFC7240"><stream>IETF</stream> <front> <title>Prefer Header for HTTP</title> <author fullname="J. Snell" asciiFullname="J. Snell"></author> <date month="June" year="2014"></date> <keyword>http</keyword><keyword>prefer</keyword> <abstract>  <t anchor="_35c79195-d8bb-468a-4eea-268345d54437">This specification defines an HTTP header field that can be used by a client to request that certain behaviors be employed by a server while processing a request.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc7240" type="src"></format> <seriesInfo value=" 10.17487/RFC7240" name="DOI"></seriesInfo> <seriesInfo value="7240" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc8259" anchor="RFC8259"><stream>IETF</stream> <front> <title>The JavaScript Object Notation (JSON) Data Interchange Format</title> <author fullname="T. Bray" asciiFullname="T. Bray"></author> <date month="December" year="2017"></date> <abstract>  <t anchor="_669ccc1c-b44a-5b55-d418-89f2920520e1">JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data.</t>  <t anchor="_bb50c850-8819-dbd8-a100-4b58404ece23">This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc8259" type="src"></format> <seriesInfo name="STD" value="90"></seriesInfo> <seriesInfo value=" 10.17487/RFC8259" name="DOI"></seriesInfo> <seriesInfo value="90" name="BCP"></seriesInfo> <seriesInfo value="8259" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc6570" anchor="RFC6570"><stream>IETF</stream> <front> <title>URI Template</title> <author fullname="J. Gregorio" asciiFullname="J. Gregorio"></author> <author fullname="R. Fielding" asciiFullname="R. Fielding"></author> <author fullname="M. Hadley" asciiFullname="M. Hadley"></author> <author fullname="M. Nottingham" asciiFullname="M. Nottingham"></author> <author fullname="D. Orchard" asciiFullname="D. Orchard"></author> <date month="March" year="2012"></date> <keyword>template</keyword><keyword>Uniform Resource Identifier</keyword><keyword>URI</keyword><keyword>URI Template</keyword><keyword>Internationalized Resource Identifier</keyword><keyword>IRI</keyword><keyword>IRI Template</keyword> <abstract>  <t anchor="_9a2a6f24-823e-db43-bef4-2fd27f6910f8">A URI Template is a compact sequence of characters for describing a range of Uniform Resource Identifiers through variable expansion. This specification defines the URI Template syntax and the process for expanding a URI Template into a URI reference, along with guidelines for the use of URI Templates on the Internet. [STANDARDS-TRACK]</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc6570" type="src"></format> <seriesInfo value=" 10.17487/RFC6570" name="DOI"></seriesInfo> <seriesInfo value="6570" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc6749" anchor="RFC6749"><stream>IETF</stream> <front> <title>The OAuth 2.0 Authorization Framework</title> <author fullname="D. Hardt" asciiFullname="D. Hardt"></author> <date month="October" year="2012"></date> <keyword>Client</keyword><keyword>Resource Owner</keyword><keyword>Authorization Server</keyword><keyword>Resource Server</keyword><keyword>Token Endpoint</keyword><keyword>Authorization Endpoint</keyword><keyword>Authorization Request</keyword><keyword>Authorization Grant</keyword><keyword>Protected Resource</keyword><keyword>Access Token</keyword><keyword>RefreshÂ Token</keyword><keyword>Authorization Code</keyword><keyword>Implicit Grant</keyword><keyword>Client Identifier</keyword><keyword>Access Token Scope</keyword><keyword>Delegation</keyword> <abstract>  <t anchor="_4c61d331-cd79-fa22-c853-4909b42ff379">The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf. This specification replaces and obsoletes the OAuth 1.0 protocol described in RFC 5849. [STANDARDS-TRACK]</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc6749" type="src"></format> <seriesInfo value=" 10.17487/RFC6749" name="DOI"></seriesInfo> <seriesInfo value="6749" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc6750" anchor="RFC6750"><stream>IETF</stream> <front> <title>The OAuth 2.0 Authorization Framework: Bearer Token Usage</title> <author fullname="M. Jones" asciiFullname="M. Jones"></author> <author fullname="D. Hardt" asciiFullname="D. Hardt"></author> <date month="October" year="2012"></date> <keyword>Client</keyword><keyword>Resource Owner</keyword><keyword>Authorization Server</keyword><keyword>Resource Server,Â Token Endpoint</keyword><keyword>Authorization Endpoint</keyword><keyword>Authorization Request,Â Authorization Grant</keyword><keyword>Protected Resource</keyword><keyword>Access Token</keyword><keyword>RefreshÂ Token</keyword><keyword>Authorization Code</keyword><keyword>Implicit Grant</keyword><keyword>Client Identifier,Â Access Token Scope</keyword><keyword>Bearer Authorization Header</keyword><keyword>Bearer AccessÂ Token Type</keyword> <abstract>  <t anchor="_c2a12785-3aa2-ca6a-feb7-ed2fa8af9627">This specification describes how to use bearer tokens in HTTP requests to access OAuth 2.0 protected resources. Any party in possession of a bearer token (a "bearer") can use it to get access to the associated resources (without demonstrating possession of a cryptographic key). To prevent misuse, bearer tokens need to be protected from disclosure in storage and in transport. [STANDARDS-TRACK]</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc6750" type="src"></format> <seriesInfo value=" 10.17487/RFC6750" name="DOI"></seriesInfo> <seriesInfo value="6750" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc7519" anchor="RFC7519"><stream>IETF</stream> <front> <title>JSON Web Token (JWT)</title> <author fullname="M. Jones" asciiFullname="M. Jones"></author> <author fullname="J. Bradley" asciiFullname="J. Bradley"></author> <author fullname="N. Sakimura" asciiFullname="N. Sakimura"></author> <date month="May" year="2015"></date> <keyword>Assertion</keyword><keyword>Claim</keyword><keyword>Security Token</keyword><keyword>JavaScript Object Notation</keyword><keyword>JSON</keyword><keyword>JSON Web Token</keyword><keyword>JWT</keyword><keyword>JSON Object Signing and Encryption</keyword><keyword>JOSE</keyword><keyword>JSON Web Signature</keyword><keyword>JWS</keyword><keyword>JSON Web Encryption</keyword><keyword>JWE</keyword><keyword>JSON Web Key</keyword><keyword>JWK</keyword><keyword>JSON Web Algorithms</keyword><keyword>JWA</keyword> <abstract>  <t anchor="_b408a194-778e-a119-82f7-677e7ae64b7b">JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc7519" type="src"></format> <seriesInfo value=" 10.17487/RFC7519" name="DOI"></seriesInfo> <seriesInfo value="7519" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc9082" anchor="RFC9082"><stream>IETF</stream> <front> <title>Registration Data Access Protocol (RDAP) Query Format</title> <author fullname="S. Hollenbeck" asciiFullname="S. Hollenbeck"></author> <author fullname="A. Newton" asciiFullname="A. Newton"></author> <date month="June" year="2021"></date> <abstract>  <t anchor="_a7707dbf-218a-9d4a-73df-a44f3c17ea22">This document describes uniform patterns to construct HTTP URLs that may be used to retrieve registration information from registries (including both Regional Internet Registries (RIRs) and Domain Name Registries (DNRs)) using "RESTful" web access patterns. These uniform patterns define the query syntax for the Registration Data Access Protocol (RDAP). This document obsoletes RFC 7482.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc9082" type="src"></format> <seriesInfo name="STD" value="95"></seriesInfo> <seriesInfo value=" 10.17487/RFC9082" name="DOI"></seriesInfo> <seriesInfo value="95" name="BCP"></seriesInfo> <seriesInfo value="9082" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc6902" anchor="RFC6902"><stream>IETF</stream> <front> <title>JavaScript Object Notation (JSON) Patch</title> <author fullname="P. Bryan" asciiFullname="P. Bryan"></author> <author fullname="M. Nottingham" asciiFullname="M. Nottingham"></author> <date month="April" year="2013"></date> <abstract>  <t anchor="_bc660973-4d00-3600-a01b-c378f120f28d">JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JavaScript Object Notation (JSON) document; it is suitable for use with the HTTP PATCH method. The "application/json-patch+json" media type is used to identify such patch documents.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc6902" type="src"></format> <seriesInfo value=" 10.17487/RFC6902" name="DOI"></seriesInfo> <seriesInfo value="6902" name="RFC"></seriesInfo></reference>
        <reference anchor="XML">
          <front>
            <title>Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E. and Yergeau, F., "Extensible Markup Language (XML) 1.0 (Fifth Edition)", World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, []().</title><author surname="Unknown"></author>
          </front>
        </reference>
        <reference anchor="I-D.draft-ietf-oauth-selective-disclosure-jwt">
          <front>
            <title>Fett D., Yasuda K. and Campbell B. , "Selective Disclosure for JWTs (SD-JWT)", Work in Progress, Internet-Draft, draft-ietf-oauth-selective-disclosure-jwt, 16 January 2025 &#x3e;</title><author surname="Unknown"></author>
          </front>
        </reference>
        <reference target="https://www.rfc-editor.org/info/rfc9396" anchor="RFC9396"><stream>IETF</stream> <front> <title>OAuth 2.0 Rich Authorization Requests</title> <author fullname="T. Lodderstedt" asciiFullname="T. Lodderstedt"></author> <author fullname="J. Richer" asciiFullname="J. Richer"></author> <author fullname="B. Campbell" asciiFullname="B. Campbell"></author> <date month="May" year="2023"></date> <keyword>security</keyword><keyword>oauth2</keyword> <abstract>  <t anchor="_512961cd-34fe-afc5-007b-d3daeab9e621">This document specifies a new parameter authorization_details that is used to carry fine-grained authorization data in OAuth messages.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc9396" type="src"></format> <seriesInfo value=" 10.17487/RFC9396" name="DOI"></seriesInfo> <seriesInfo value="9396" name="RFC"></seriesInfo></reference>
        <reference target="https://www.rfc-editor.org/info/rfc9205" anchor="RFC9205"><stream>IETF</stream> <front> <title>Building Protocols with HTTP</title> <author fullname="M. Nottingham" asciiFullname="M. Nottingham"></author> <date month="June" year="2022"></date> <keyword>HTTP API</keyword> <abstract>  <t anchor="_f5a0a295-29ae-8444-d6a9-8e8821e2bec5">Applications often use HTTP as a substrate to create HTTP-based APIs. This document specifies best practices for writing specifications that use HTTP to define new application protocols. It is written primarily to guide IETF efforts to define application protocols using HTTP for deployment on the Internet but might be applicable in other situations.</t>  <t anchor="_fca7f35c-e00b-6d35-0fe1-fba88a0a5ba5">This document obsoletes RFC 3205.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc9205" type="src"></format> <seriesInfo value=" 10.17487/RFC9205" name="DOI"></seriesInfo> <seriesInfo value="56" name="BCP"></seriesInfo> <seriesInfo value="9205" name="RFC"></seriesInfo></reference>
        <reference anchor="RPPReq">
          <front>
            <title>"RPP Requirements (Work in progress 7.3.2025)", https:/ /github.com/ietf/wiki.ietf.org/blob/157294ff0fdfb2715da5a287dfba6c641a1bad67/group/rpp/requirements.md</title><author surname="Unknown"></author>
          </front>
        </reference>
        <reference target="https://www.rfc-editor.org/info/rfc8949" anchor="RFC8949"><stream>IETF</stream> <front> <title>Concise Binary Object Representation (CBOR)</title> <author fullname="C. Bormann" asciiFullname="C. Bormann"></author> <author fullname="P. Hoffman" asciiFullname="P. Hoffman"></author> <date month="December" year="2020"></date> <keyword>parser</keyword><keyword>decoder</keyword><keyword>encoder</keyword><keyword>binary format</keyword><keyword>data interchange format</keyword><keyword>JSON</keyword> <abstract>  <t anchor="_e3233b40-fef1-8f39-e542-7d206a9671fe">The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t>  <t anchor="_6ae4ee2c-6ac7-1248-7fe4-0de1ad431619">This document obsoletes RFC 7049, providing editorial improvements, new details, and errata fixes while keeping full compatibility with the interchange format of RFC 7049. It does not create a new version of the format.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc8949" type="src"></format> <seriesInfo name="STD" value="94"></seriesInfo> <seriesInfo value=" 10.17487/RFC8949" name="DOI"></seriesInfo> <seriesInfo value="94" name="BCP"></seriesInfo> <seriesInfo value="8949" name="RFC"></seriesInfo></reference>
        <reference anchor="OpenAPI">
          <front>
            <title>"OpenAPI Specification", </title><author surname="Unknown"></author>
          </front>
        </reference>
        <reference anchor="W3C-VC">
          <front>
            <title>Verifiable Credentials Data Model v2.0, </title><author surname="Unknown"></author>
          </front>
        </reference>
        <reference anchor="I-D.draft-ietf-oauth-sd-jwt-vc">
          <front>
            <title>SD-JWT-based Verifiable Credentials (SD-JWT VC) &#x3e;</title><author surname="Unknown"></author>
          </front>
        </reference>
        <reference target="https://www.rfc-editor.org/info/rfc9553" anchor="RFC9553"><stream>IETF</stream> <front> <title>JSContact: A JSON Representation of Contact Data</title> <author fullname="R. Stepanek" asciiFullname="R. Stepanek"></author> <author fullname="M. Loffredo" asciiFullname="M. Loffredo"></author> <date month="May" year="2024"></date> <keyword>JSON</keyword><keyword>addressbook</keyword><keyword>contacts</keyword><keyword>cards</keyword><keyword>VCARD</keyword> <abstract>  <t anchor="_eecf9d6a-d0af-ffe2-933f-93f16ce5eb5d">This specification defines a data model and JavaScript Object Notation (JSON) representation of contact card information that can be used for data storage and exchange in address book or directory applications. It aims to be an alternative to the vCard data format and to be unambiguous, extendable, and simple to process. In contrast to the JSON-based jCard format, it is not a direct mapping from the vCard data model and expands semantics where appropriate. Two additional specifications define new vCard elements and how to convert between JSContact and vCard.</t></abstract> </front> <format target="https://www.rfc-editor.org/info/rfc9553" type="src"></format> <seriesInfo value=" 10.17487/RFC9553" name="DOI"></seriesInfo> <seriesInfo value="9553" name="RFC"></seriesInfo></reference>
      </references>
    </references>
  </back>
</rfc>
